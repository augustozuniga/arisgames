<?xml version="1.0" encoding="utf-8"?>
<mx:UIComponent xmlns:mx="http://www.adobe.com/2006/mxml">
	
	<mx:RemoteObject id="editors"
		source="aris.editors"
		destination="amfphp"
		showBusyCursor="true">
		<mx:method name="createEditor" result="on_editors_createEditorResult(event)"/>
		<mx:method name="login" result="on_editors_loginResult(event)"/>
	</mx:RemoteObject>
	
	<mx:RemoteObject id="events"
		source="aris.events"
		destination="amfphp"
		showBusyCursor="true">
		<mx:method name="createEvent" result="on_events_createEventResult(event)"/>
		<mx:method name="deleteEvent" result="on_events_deleteEventResult(event)"/>
		<mx:method name="getEvents" result="on_events_getEventsResult(event)"/>
	</mx:RemoteObject>

	<mx:RemoteObject id="games"
		source="aris.games"
		destination="amfphp"
		showBusyCursor="true">
		<mx:method name="copyGame" result="on_games_copyGameResult(event)"/>
		<mx:method name="createGame" result="on_games_createGameResult(event)"/>
		<mx:method name="deleteGame" result="on_games_deleteGameResult(event)"/>
		<mx:method name="getGamesForEditor" result="on_games_getGamesForEditorResult(event)"/>
		<mx:method name="setGameName" result="on_games_setGameNameResult(event)"/>
	</mx:RemoteObject>
	
	<mx:RemoteObject id="items"
		source="aris.items"
		destination="amfphp"
		showBusyCursor="true">
		<mx:method name="createItem" result="on_items_createItemResult(event)"/>
		<mx:method name="deleteItem" result="on_items_deleteItemResult(event)"/>
		<mx:method name="getItem" result="on_items_getItemResult(event)"/>
		<mx:method name="getItems" result="on_items_getItemsResult(event)"/>
		<mx:method name="getReferrers" result="on_items_getReferrersResult(event)"/>
		<mx:method name="updateItem" result="on_items_updateItemResult(event)"/>
	</mx:RemoteObject>
	
	<mx:RemoteObject id="locations"
		source="aris.locations"
		destination="amfphp"
		showBusyCursor="true">
		<mx:method name="createLocationForItem" result="on_locations_createLocationForItemResult(event)"/>
		<mx:method name="createLocationForNode" result="on_locations_createLocationForNodeResult(event)"/>
		<mx:method name="createLocationForNpc" result="on_locations_createLocationForNpcResult(event)"/>
		<mx:method name="deleteLocation" result="on_locations_deleteLocationResult(event)"/>
		<mx:method name="getLocation" result="on_locations_getLocationResult(event)"/>
		<mx:method name="getLocations" result="on_locations_getLocationsResult(event)"/>
		<mx:method name="objectTypeOptions" result="on_locations_objectTypeOptionsResult(event)"/>
		<mx:method name="updateAttributes" result="on_locations_updateAttributesResult(event)"/>
	</mx:RemoteObject>
	
	<mx:RemoteObject id="media"
		source="aris.media"
		destination="amfphp"
		showBusyCursor="true">
		<mx:method name="createMedia" result="on_media_createMediaResult(event)"/>
		<mx:method name="deleteMedia" result="on_media_deleteMediaResult(event)"/>
		<mx:method name="getMedia" result="on_media_getMediaResult(event)"/>
		<mx:method name="getValidAudioExtensions" result="on_media_getValidAudioExtensionsResult(event)"/>
		<mx:method name="getValidImageExtensions" result="on_media_getValidImageExtensionsResult(event)"/>
		<mx:method name="getValidVideoExtensions" result="on_media_getValidVideoExtensionsResult(event)"/>
		<mx:method name="updateMedia" result="on_media_updateMediaResult(event)"/>
	</mx:RemoteObject>
	
	<mx:RemoteObject id="nodes"
		source="aris.nodes"
		destination="amfphp"
		showBusyCursor="true">
		<mx:method name="createNode" result="on_nodes_createNodeResult(event)"/>
		<mx:method name="deleteNode" result="on_nodes_deleteNodeResult(event)"/>
		<mx:method name="getNode" result="on_nodes_getNodeResult(event)"/>
		<mx:method name="getNodes" result="on_nodes_getNodesResult(event)"/>
		<mx:method name="getReferrers" result="on_nodes_getReferrersResult(event)"/>
		<mx:method name="updateNode" result="on_nodes_updateNodeResult(event)"/>
	</mx:RemoteObject>

	<mx:RemoteObject id="npcs"
		source="aris.npcs"
		destination="amfphp"
		showBusyCursor="true">
		<mx:method name="createConversation" result="on_npcs_createConversationResult(event)"/>
		<mx:method name="createNpc" result="on_npcs_createNpcResult(event)"/>
		<mx:method name="deleteConversation" result="on_npcs_deleteConversationResult(event)"/>
		<mx:method name="deleteNpc" result="on_npcs_deleteNpcResult(event)"/>
		<mx:method name="getConversations" result="on_npcs_getConversationsResult(event)"/>
		<mx:method name="getNpc" result="on_npcs_getNpcResult(event)"/>
		<mx:method name="getNpcs" result="on_npcs_getNpcsResult(event)"/>
		<mx:method name="getReferrers" result="on_npcs_getReferrersResult(event)"/>
		<mx:method name="updateConversation" result="on_npcs_updateConversationResult(event)"/>
		<mx:method name="updateNpc" result="on_npcs_updateNpcResult(event)"/>
	</mx:RemoteObject>
	
	<mx:RemoteObject id="playerStateChanges"
		source="aris.playerStateChanges"
		destination="amfphp"
		showBusyCursor="true">
		<mx:method name="createPlayerStateChange" result="on_playerStateChanges_createPlayerStateChangeResult(event)"/>
		<mx:method name="deletePlayerStateChange" result="on_playerStateChanges_deletePlayerStateChangeResult(event)"/>
		<mx:method name="getPlayerStateChangesForObject" result="on_playerStateChanges_getPlayerStateChangesForObjectResult(event)"/>
		<mx:method name="getReferrers" result="on_playerStateChanges_getReferrersResult(event)"/>
		<mx:method name="updatePlayerStateChange" result="on_playerStateChanges_updatePlayerStateChangeResult(event)"/>
	</mx:RemoteObject>
	
	<mx:RemoteObject id="quests"
		source="aris.quests"
		destination="amfphp"
		showBusyCursor="true">
		<mx:method name="createQuest" result="on_quests_createQuestResult(event)"/>
		<mx:method name="deleteQuest" result="on_quests_deleteQuestResult(event)"/>
		<mx:method name="getQuest" result="on_quests_getQuestResult(event)"/>
		<mx:method name="getQuests" result="on_quests_getQuestsResult(event)"/>
		<mx:method name="updateQuest" result="on_quests_updateQuestResult(event)"/>
	</mx:RemoteObject>

	<mx:RemoteObject id="qrcodes"
		source="aris.qrcodes"
		destination="amfphp"
		showBusyCursor="true">
		<mx:method name="createQRcode" result="on_qrcodes_createQRCodeResult(event)"/>
		<mx:method name="deleteQRCode" result="on_qrcodes_deleteQRCodeResult(event)"/>
		<mx:method name="getQRCode" result="on_qrcodes_getQRCodeResult(event)"/>
		<mx:method name="getQRCodes" result="on_qrcodes_getQRCodesResult(event)"/>
		<mx:method name="updateQRCode" result="on_qrcodes_updateQRCodeResult(event)"/>
	</mx:RemoteObject>

	<mx:RemoteObject id="requirements"
		source="aris.requirements"
		destination="amfphp"
		showBusyCursor="true">
		<mx:method name="createRequirement" result="on_requirements_createRequirementResult(event)"/>
		<mx:method name="deleteRequirement" result="on_requirements_deleteRequirementResult(event)"/>
		<mx:method name="getRequirementsForObject" result="on_requirements_getRequirementsForObjectResult(event)"/>
		<mx:method name="getReferrers" result="on_requirements_getReferrersResult(event)"/>
		<mx:method name="updateRequirement" result="on_requirements_updateRequirementResult(event)"/>
	</mx:RemoteObject>
	
	<mx:Script>
		<![CDATA[
			import mx.binding.utils.ChangeWatcher;
			import mx.managers.CursorManager;
			import mx.collections.ArrayCollection;
			import mx.controls.Alert;
			import mx.rpc.events.ResultEvent;
			
			import org.arisgames.editor.view.View;
			
			[Bindable] public var availableGamesArrayCollection:ArrayCollection;
			[Bindable] public var gameObjectsArrayCollection:ArrayCollection;
			
			private var availableGamesArray:Array;
			private var currentView:View;
			private var currentEditorID:int;
			private var currentGameID:int;
			private var currentGameName:String;
			private var currentGameObject:GameObject;
			private var gameObjectsArray:Array;
			private var loggedIn:Boolean;
			private var creatingNewObject:Boolean;
			
			private var eventList:Array;
			private var gpsInstanceList:Array;
			private var qrCodeInstanceList:Array;
			private var characterFolder:Folder;
			private var itemFolder:Folder;
			private var pageFolder:Folder;
			private var questFolder:Folder;
			private var mediaFolder:Folder;
			
			/////////////
			// Getters //
			/////////////
			
			public function getCurrentGameName():String
			{
				return currentGameName;
			}
			
			public function getGPSInstances():Array
			{
				return gpsInstanceList;
			}
			
			public function getQRCodeInstances():Array
			{
				return qrCodeInstanceList;
			}
			
			public function isLoggedIn():Boolean
			{
				return loggedIn;
			}
			
			////////////////////////////
			// Other Public Functions //
			////////////////////////////
			
			public function addChoice(ref:GameObjectReference):void
			{
				if(currentGameObject is Character)
				{
					(currentGameObject as Character).addChoice(new Choice(ref,
																		  "Ask about " + ref.label,
																		  -1 - currentGameObject.getAddCounter()
																		  )
															   );
				}
				else if(currentGameObject is Page)
				{
					(currentGameObject as Page).addChoice(new Choice(ref,
																	 "Go to " + ref.label,
																	 -1 - currentGameObject.getAddCounter()
																	 )
														  );
				} 
			}
			
			public function addModification(ref:GameObjectReference):void
			{
				if(currentGameObject is Item)
				{
					(currentGameObject as Item).addPlayerModification(new PlayerModification(ref,
																							 PlayerModification.DB_CODES[0],
																							 -1 - currentGameObject.getAddCounter()
																							 )
																	 );				
				}
				else if(currentGameObject is Page)
				{
					(currentGameObject as Page).addPlayerModification(new PlayerModification(ref,
																							 PlayerModification.DB_CODES[0],
																							 -1 - currentGameObject.getAddCounter()
																							 )
																	 );									
				}
			}
			
			public function addObjective(ref:GameObjectReference):void
			{
				if(currentGameObject is Quest)
				{
					(currentGameObject as Quest).addObjective(new Requirement(ref, 0,
																			  -1 - currentGameObject.getAddCounter(),
																			  getEventIDFromEventCode(ref.getType() + ref.getID().toString())
																			  )
															  );
				}
			}
			
			public function addQRCode(ref:GameObjectReference):void
			{
				
			}
			
			public function addRequirement(ref:GameObjectReference):void
			{
				currentGameObject.addRequirement(new Requirement(ref, 0,
																 -1 - currentGameObject.getAddCounter(),
																 getEventIDFromEventCode(ref.getType() + ref.getID().toString())
																 )
												);
			}

			public function closeGame():void
			{
				updateCurrentGame();
				currentView.goToMainMenu();
				updateGameList();
				currentGameObject = null;
			}
			
			public function copyGame(ref:GameReference):void
			{
				games.copyGame.send(ref.getID(), "copyOf" + ref.name, "Copy of " + ref.name);
			}
			
			public function createGame():void
			{
				currentGameName = "My New Game";
				games.createGame.send(currentEditorID, currentGameName);
			}
			
			public function createNewGameObject(gen:Generator):void
			{
				this.creatingNewObject = true;
				var type:String = gen.getType();
				if(type == GameObjectReference.CHARACTER)
				{//takes gameID, name, descr, greeting, media, returns npcID
					npcs.createNpc.send(currentGameID, "My New Character", "", "", "");
				}
				else if(type == GameObjectReference.ITEM)
				{//takes gameID, name, descr, media, droppable, destroyable, returns id
					items.createItem.send(currentGameID, "My New Item", "", "", 0, 0);
				}
				else if(type == GameObjectReference.PAGE)
				{//takes gameID, title, text, media, opt1text, opt1id, 2txt, 2id, 3txt, 3id, qacorrecttext, qaincorrectnodeid, qacorrectid
					nodes.createNode.send(currentGameID, "My New Page", "", "",
										  "", 0, "", 0, "", 0, "", 0, 0);
				}
				else if(type == GameObjectReference.QUEST)
				{//takes gameID, name, incompletedesc, completedesc, media, returns id
					quests.createQuest.send(currentGameID, "My New Quest", "", "", "");
				}
				else if(type == GameObjectReference.MEDIA)
				{
					var uploader:MediaUploader = new MediaUploader(this);
				}
				else
				{
					Alert.show("Error in Model.createNewGameObject: unrecognized generator type.");
				}
			}
			
			public function deleteGame(ref:GameReference):void
			{
				games.deleteGame.send(ref.getID());
			}
			
			public function deleteGameObject(ref:GameObjectReference):void
			{
				var type:String = ref.getType();
				if(type == GameObjectReference.CHARACTER)
				{
					npcs.deleteNpc.send(currentGameID, ref.getID());
				}
				else if(type == GameObjectReference.ITEM)
				{
					items.deleteItem.send(currentGameID, ref.getID());
					events.deleteEvent.send(currentGameID,
											getEventIDFromEventCode(GameObjectReference.ITEM + ref.getID().toString())
											);
				}
				else if(type == GameObjectReference.PAGE)
				{
					nodes.deleteNode.send(currentGameID, ref.getID());
					events.deleteEvent.send(currentGameID,
											getEventIDFromEventCode(GameObjectReference.PAGE + ref.getID().toString())
											);
				}
				else if(type == GameObjectReference.QUEST)
				{
					quests.deleteQuest.send(currentGameID, ref.getID());
				}
			}
			
			public function editGame(ref:GameReference):void
			{
				currentGameID = ref.getID();
				currentGameName = ref.name;
				currentView.goToGameEditor();
				getCurrentGameData();
			}
			
			public function getCurrentGameObject():GameObject
			{
				return currentGameObject;
			}
			
			public function goToGameObjectInstance(instance:GameObjectInstance):void
			{
				if( currentGameObject == null || !(instance.belongsToGameObject(currentGameObject)) )
				{
					setCurrentGameObject(getGameObjectReference(instance.getObjectID(), instance.getObjectType()));
				}
			}
			
			public function init(view:View):void
			{
				GameReference.init(this);
				media.getValidAudioExtensions.send();
				media.getValidImageExtensions.send();
				media.getValidVideoExtensions.send();
				
				this.currentView = view;
				this.loggedIn = false;
				this.creatingNewObject = false;
				this.availableGamesArray = new Array();
				this.availableGamesArrayCollection = new ArrayCollection(this.availableGamesArray);
				
				this.eventList = new Array();
				this.gpsInstanceList = new Array();
				this.qrCodeInstanceList = new Array();
				
				this.characterFolder = new Folder("Characters", GameObjectReference.CHARACTER, "Create New Character");
				this.itemFolder = new Folder("Items", GameObjectReference.ITEM, "Create New Item");
				this.pageFolder = new Folder("Pages", GameObjectReference.PAGE, "Create New Page");
				this.questFolder = new Folder("Quests", GameObjectReference.QUEST, "Create New Quest");
				this.mediaFolder = new Folder("Media", GameObjectReference.MEDIA, "Upload New Media File");
				this.gameObjectsArray = [characterFolder, itemFolder, pageFolder, questFolder, mediaFolder];
				this.gameObjectsArrayCollection = new ArrayCollection(gameObjectsArray);
			}
			
			public function isReady():Boolean
			{ 
				return (CursorManager.currentCursorID == CursorManager.NO_CURSOR);
			}
			
			public function loginUser(username:String, password:String):void
			{
				if(!loggedIn)
				{
					editors.login.send(username, password);				
				}
				else
				{
					Alert.show("You are already logged in.");
				}
			}
			
			public function registerNewUser(username:String, password:String, email:String, comments:String):void
			{
				editors.createEditor.send(username, password, email, comments);
			}
			
			public function removeChoice(choiceToRemove:Choice):void
			{
				if(currentGameObject is Page)
				{
					(currentGameObject as Page).removeChoice(choiceToRemove);
				}
			}
			
			public function removePlayerModification(mod:PlayerModification):void
			{
				if(currentGameObject is Item)
				{
					(currentGameObject as Item).removePlayerModification(mod);
				}
				else if(currentGameObject is Page)
				{
					(currentGameObject as Page).removePlayerModification(mod);
				}
			}
			
			public function removeRequirement(req:Requirement):void
			{// note that Quest overrides the following method to remove from the appropriate group (requirements or objectives)
				currentGameObject.removeRequirement(req);
			}
			
			public function renameGame(gameID:int, newName:String):void
			{
				games.setGameName.send(gameID, newName);
			}
			
			public function setCurrentGameObject(objRef:GameObjectReference):void
			{
				updateCurrentGame();
				getCurrentGameData();
				if(objRef != null)
				{
					var id:int = objRef.getID();
					var type:String = objRef.getType();
					if(type == GameObjectReference.CHARACTER)
					{
						npcs.getNpc.send(currentGameID, id);
					}
					else if(type == GameObjectReference.ITEM)
					{
						items.getItem.send(currentGameID, id);
						playerStateChanges.getPlayerStateChangesForObject.send(currentGameID, type, id);
					}
					else if(type == GameObjectReference.PAGE)
					{
						nodes.getNode.send(currentGameID, id);
						playerStateChanges.getPlayerStateChangesForObject.send(currentGameID, type, id);
					}
					else if(type == GameObjectReference.QUEST)
					{
						quests.getQuest.send(currentGameID, id);
						requirements.getRequirementsForObject.send(currentGameID, Requirement.QUEST_COMPLETE, id);
						type = Requirement.QUEST_DISPLAY;
					}
					else
					{
						Alert.show("Error in Model.setCurrentGameObject: unkown object type.");
						return;
					}
					requirements.getRequirementsForObject.send(currentGameID, type, id);
				}
			}
			
			public function updateCompletedDescription(newDescription:String):void
			{
				(currentGameObject as Quest).setCompletedDescription(newDescription);
			}
			
			public function updateCurrentGameName(newName:String):void
			{
				currentGameName = newName;
			}
			
			public function updateDestroyable(newValue:Boolean):void
			{
				(currentGameObject as Item).setDestroyable(newValue);
			}
			
			public function updateDroppable(newValue:Boolean):void
			{
				(currentGameObject as Item).setDroppable(newValue);
			}
			
			public function updateGameObjectDescription(newDescription:String):void
			{
				currentGameObject.setDescription(newDescription);
			}
			
			public function updateGameObjectName(newName:String):void
			{
				currentGameObject.setName(newName);
				gameObjectsArrayCollection.itemUpdated(gameObjectsArray);
			}
			
			public function updateGreeting(newGreeting:String):void
			{
				(currentGameObject as Character).setGreeting(newGreeting);
			}
			
			public function uploadMedia(fileRef:FileReference):void
			{
				var params:URLVariables = new URLVariables();
				params.gameID = currentGameID;
				var request:URLRequest = new URLRequest("http://atsosxdev.doit.wisc.edu/aris/editor/server/services/aris/uploadHandler.php");
				request.method = URLRequestMethod.POST;
				request.data = params;
				fileRef.upload(request);
				media.createMedia.send(currentGameID, fileRef.name);
				getCurrentGameData();
			}
			
			
			///////////////////////
			// Private Functions //
			///////////////////////
			
			private function assignInstances():void
			{
				if(currentGameObject is InstantiatedGameObject)
				{
					for each(var qr:QRCodeInstance in qrCodeInstanceList)
					{
						if(qr.belongsToGameObject(currentGameObject))
						{
							(currentGameObject as InstantiatedGameObject).addQRCodeInstance(qr);							
							qr.getMarker().showHalo();
						}
					}					
				}
				else
				{
					Alert.show("Error in Model.assignInstances: currentGameObject is not an InstantiatedGameObject");
				}
			}
			
			private function filterErrors(event:ResultEvent, fname:String):Boolean
			{
				if(event.result.returnCode == 0)
				{
					return true;
				}
				else
				{
					var message:String = "Server Error\nSource: " + fname + "\nReturn Code: " + event.result.returnCode.toString();
					if(event.result.returnCodeDescription != null)
					{
						message += "\nDescription: " + event.result.returnCodeDescription;
					}
					Alert.show(message);
					return false;
				}
			}
			
			private function getCurrentGameData():void
			{
				events.getEvents.send(currentGameID);
				npcs.getNpcs.send(currentGameID);
				items.getItems.send(currentGameID);
				nodes.getNodes.send(currentGameID);
				quests.getQuests.send(currentGameID);
				media.getMedia.send(currentGameID);
				qrcodes.getQRCodes.send(currentGameID);
				//locations.getLocations.send(currentGameID);				
			}
			
			private function getEventCodeFromEvent(id:int):String
			{
				for each(var evt:Object in eventList)
				{
					if(evt.event_id as int == id)
					{
						return evt.description;
					}
				}
				return null;			
			}
			
			private function getEventIDFromEventCode(evtCode:String):int
			{
				if(evtCode != null)
				{
					for each(var evt:Object in eventList)
					{
						if(evt.description.toString() == evtCode)
						{
							return int(evt.event_id);
						}
					}
					Alert.show("Error in model.getEventIDFromEventCode: event not found");
				}
				return -1;
			}
			
			private function getGameObjectReference(id:int, type:String):GameObjectReference
			{
				var folder:Folder = null;
				if(type == GameObjectReference.CHARACTER)
				{
					folder = characterFolder;
				}
				else if(type == GameObjectReference.ITEM)
				{
					folder = itemFolder;
				}
				else if(type == GameObjectReference.PAGE)
				{
					folder = pageFolder;
				}
				else if(type == GameObjectReference.QUEST)
				{
					folder = questFolder;
				}
				if(folder != null)
				{
					for each(var ref:Object in folder.children)
					{
						if(ref is GameObjectReference && (ref as GameObjectReference).getID() == id)
						{
							return (ref as GameObjectReference);
						}
					}					
				}
				return null;
			}
			
			private function getGameObjectReferenceFromEventCode(code:String):GameObjectReference
			{
				var objID:int;
				var objType:String;
				if(code.indexOf(GameObjectReference.ITEM) == 0)
				{
					objType = GameObjectReference.ITEM;
					objID = int(code.substr(GameObjectReference.ITEM.length));
					return getGameObjectReference(objID, objType);
				}
				else if(code.indexOf(GameObjectReference.PAGE) == 0)
				{
					objType = GameObjectReference.PAGE;
					objID = int(code.substr(GameObjectReference.PAGE.length));
					return getGameObjectReference(objID, objType);
				}				
				return null;
			}
			
			private function getModification(id:int):PlayerModification
			{
				if(currentGameObject is Item)
				{
					return (currentGameObject as Item).getModification(id);
				}
				else if(currentGameObject is Page)
				{
					return (currentGameObject as Page).getModification(id);
				}
				Alert.show("Error in Model.updateCurrentGame(): unrecognized object type with PlayerModification");
				return null;
			}

			private function on_editors_createEditorResult(event:ResultEvent):void
			{
				if(filterErrors(event, "editors.createEditor"))
				{
					currentEditorID = int(event.result.data);
					loggedIn = true;
					updateGameList();
					updateView();
				}				
			}
			
			private function on_editors_loginResult(event:ResultEvent):void
			{
				if(filterErrors(event, "editors.login"))
				{
					currentEditorID = int(event.result.data);
					loggedIn = true;
					updateGameList();
					updateView();
				}
			}
			
			private function on_events_createEventResult(event:ResultEvent):void
			{ //takes gameID, description, returns id
				filterErrors(event, "events.createEvent");
				playerStateChanges.createPlayerStateChange.send(currentGameID,
																currentGameObject.getType(),
																currentGameObject.getID(),
																PlayerModification.GIVE_EVENT,
																int(event.result.data)
																);
			}
			
			private function on_events_deleteEventResult(event:ResultEvent):void
			{ //takes gameID, eventID, returns true if successful
				filterErrors(event, "events.deleteEvent");
			}
			
			private function on_events_getEventsResult(event:ResultEvent):void
			{ //takes gameID, returns array of obj{description, event_id}
				if(filterErrors(event, "events.getEvents"))
				{
					eventList = event.result.data.source as Array;
				}
			}
			
			private function on_games_copyGameResult(event:ResultEvent):void
			{ //takes gameID, newSHortName, newFullName, returns true on success
				if(filterErrors(event, "games.copyGame"))
				{
					updateGameList();
				}
			}
			
			private function on_games_createGameResult(event:ResultEvent):void
			{ //takes editorID, strFullName, returns id
				if(filterErrors(event, "games.createGame"))
				{
					updateGameList();
					updateView();					
				}
			}
			
			private function on_games_deleteGameResult(event:ResultEvent):void
			{
				filterErrors(event, "games.deleteGame");
				updateGameList();
				updateView();
			}
			
			private function on_games_getGamesForEditorResult(event:ResultEvent):void
			{ //takes editorID, returns array obj{game_id, name, prefix}
				if(filterErrors(event, "games.getGamesForEditor"))
				{
					availableGamesArray = new Array();
					for each(var obj:Object in event.result.data)
					{
						availableGamesArray.push(new GameReference(obj.game_id, obj.name));
					}
					availableGamesArrayCollection.source = availableGamesArray;
					updateView();
				}
			}
			
			private function on_games_setGameNameResult(event:ResultEvent):void
			{ //takes gameID, newName, returns true if successful
				if(filterErrors(event, "games.setGameName"))
				{
					updateGameList();
				}
			}
			
			private function on_items_createItemResult(event:ResultEvent):void
			{ //takes gameID, name, descr, media, returns id
				if(filterErrors(event, "items.createItem"))
				{
					setCurrentGameObject(new GameObjectReference(int(event.result.data), GameObjectReference.ITEM, "My New Item"));
				}
			}
			
			private function on_items_deleteItemResult(event:ResultEvent):void
			{ //takes gameID, itemID, returns true if successful
				if(filterErrors(event, "items.deleteItem"))
				{
					currentGameObject = null;
				}
				getCurrentGameData();				
			}
			
			private function on_items_getItemResult(event:ResultEvent):void
			{ //takes gameID, itemID, returns obj{description, destroyable, dropable, item_id, media, name, type}
				if(filterErrors(event, "items.getItem"))
				{
					var requirements:Array = new Array();
					var playerModifications:Array = new Array();
					currentGameObject = new Item(getGameObjectReference(event.result.data.item_id, GameObjectReference.ITEM),
												 event.result.data.description, event.result.data.media, requirements, playerModifications,
												 int(event.result.data.dropable) == 1, int(event.result.data.destroyable) == 1);
					assignInstances();
					currentGameObject.takeSnapshot();
					if(creatingNewObject)
					{
						events.createEvent.send(currentGameID, GameObjectReference.ITEM + event.result.data.item_id.toString());
						creatingNewObject = false;
					}
					updateView();				 
				}
			}
			
			private function on_items_getItemsResult(event:ResultEvent):void
			{ //takes gameID, returns array obj{description, item_id, media, name, type}
				if(filterErrors(event, "items.getItems"))
				{
					var newChildren:Array = new Array();
					for each(var obj:Object in event.result.data)
					{
						newChildren.push(new GameObjectReference(obj.item_id, GameObjectReference.ITEM, obj.name));
					}
					itemFolder.children = newChildren;
					gameObjectsArrayCollection.itemUpdated(itemFolder);
					updateView();
				}
			}
			
			private function on_items_updateItemResult(event:ResultEvent):void
			{ //takes gameID, itemID, name, descr, media, droppable, destroyable, returns true if successful
				filterErrors(event, "items.updateItem");	
			}
			
			private function on_media_getMediaResult(event:ResultEvent):void
			{ //takes gameID returns array of obj{media_id, name}
				if(filterErrors(event, "media.getMedia"))
				{
					var newChildren:Array = new Array();
					for each(var obj:Object in event.result.data)
					{
						newChildren.push(new GameObjectReference(obj.media_id, GameObjectReference.MEDIA, obj.media));
					}
					mediaFolder.children = newChildren;
					gameObjectsArrayCollection.itemUpdated(mediaFolder);
					updateView();
				}
			}
			
			private function on_media_getValidAudioExtensionsResult(event:ResultEvent):void
			{ // takes no parameters, returns array of strings (extensions without the dot)
				if(filterErrors(event, "media.getValidAudioExtensions"))
				{
					MediaUploader.addExtensions(event.result.data as Array);
				}
			}
			
			private function on_media_getValidImageExtensionsResult(event:ResultEvent):void
			{ // takes no parameters, returns array of strings (extensions without the dot)
				if(filterErrors(event, "media.getValidImageExtensions"))
				{
					MediaUploader.addExtensions(event.result.data as Array);
				}
				
			}
			
			private function on_media_getValidVideoExtensionsResult(event:ResultEvent):void
			{ // takes no parameters, returns array of strings (extensions without the dot)
				if(filterErrors(event, "media.getValidVideoExtensions"))
				{
					MediaUploader.addExtensions(event.result.data as Array);
				}
				
			}
			
			private function on_nodes_createNodeResult(event:ResultEvent):void
			{ //takes gameID, title, text, media, opt1text, opt1nodeID, opt2text, opt2nodeID, opt3text, opt3nodeID, QAcorrectanswer, QAincorrectnodeid, QAcorrectnodeid, returns nodeID
				if(filterErrors(event, "nodes.createNode"))
				{
					setCurrentGameObject(new GameObjectReference(int(event.result.data), GameObjectReference.PAGE, "My New Page"));
				}				
			}
			
			private function on_nodes_deleteNodeResult(event:ResultEvent):void
			{ //takes gameID, nodeID, returns returnCode only
				if(filterErrors(event, "nodes.deleteNode"))
				{
					currentGameObject = null;
				}
				getCurrentGameData();				
			}
			
			private function on_nodes_getNodeResult(event:ResultEvent):void
			{ //takes gameID, nodeID, returns obj{add_event_id, add_item_id, force_layout, media, node_id, opt1_node_id, opt1_text, opt2_node_id, opt2_text, opt3_node_id, opt3_text, remove_event_id, remove_item_id, require_answer_correct_node_id, require_answer_string, require_event_id, require_item_id, require_location_id, required_condition_not_met_node_id, text, title
				if(filterErrors(event, "nodes.getNode"))
				{
					var requirements:Array = new Array();
					var playerModifications:Array = new Array();
					var choices:Array = new Array();
					var choiceID:int = int(event.result.data.opt1_node_id);
					if(choiceID > 0)
					{
						choices.push(new Choice(getGameObjectReference(choiceID, GameObjectReference.PAGE),
												event.result.data.opt1_text,
												1)
									 );
					}
					choiceID = int(event.result.data.opt2_node_id);
					if(choiceID > 0)
					{
						choices.push(new Choice(getGameObjectReference(choiceID, GameObjectReference.PAGE),
												event.result.data.opt2_text,
												2)
									 );
					}
					choiceID = int(event.result.data.opt3_node_id);
					if(choiceID > 0)
					{
						choices.push(new Choice(getGameObjectReference(choiceID, GameObjectReference.PAGE),
												event.result.data.opt3_text,
												3)
									 );
					}
					currentGameObject = new Page(getGameObjectReference(event.result.data.node_id, GameObjectReference.PAGE),
												 event.result.data.text, event.result.data.media, requirements, playerModifications, choices);
					assignInstances();
					currentGameObject.takeSnapshot();
					if(creatingNewObject)
					{
						events.createEvent.send(currentGameID, GameObjectReference.PAGE + event.result.data.node_id.toString());
						creatingNewObject = false;
					}
					updateView();				 
				}				
			}
			
			private function on_nodes_getNodesResult(event:ResultEvent):void
			{
				if(filterErrors(event, "nodes.getNodes"))
				{
					var newChildren:Array = new Array();
					for each(var obj:Object in event.result.data)
					{
						newChildren.push(new GameObjectReference(obj.node_id, GameObjectReference.PAGE, obj.title));
					}
					pageFolder.children = newChildren;
					gameObjectsArrayCollection.itemUpdated(pageFolder);
					updateView();
				}				
			}
			
			private function on_nodes_updateNodeResult(event:ResultEvent):void
			{ //takes gameID, nodeID, title, text, media, opt1text, opt1nodeID, opt2text, opt2nodeid, opt3text, opt3nodeid, QAcorrectanswer, QAincorrectnodeid, QAcorrectnodeid, returns true if successful
				filterErrors(event, "nodes.updateNode");
			}
			
			private function on_npcs_createConversationResult(event:ResultEvent):void
			{ //takes gameID, npcID, nodeID, text, returns conversationID
				filterErrors(event, "npcs.createConversation");
			}
			
			private function on_npcs_createNpcResult(event:ResultEvent):void
			{ //takes gameID, name, descr, greeting, media, returns npcID
				if(filterErrors(event, "npcs.createNpc"))
				{
					setCurrentGameObject(new GameObjectReference(int(event.result.data), GameObjectReference.CHARACTER, "My New Character"));
				}								
			}
			
			private function on_npcs_deleteConversationResult(event:ResultEvent):void
			{ //takes gameID, conversationID, returns true on success
				filterErrors(event, "npcs.deleteConversation");
			}
			
			private function on_npcs_deleteNpcResult(event:ResultEvent):void
			{ //takes gameID, npcID, returns null
				if(filterErrors(event, "npcs.deleteNpc"))
				{
					currentGameObject = null;
				}
				getCurrentGameData();
			}
			
			private function on_npcs_getConversationsResult(event:ResultEvent):void
			{ //takes gameID, npcID, returns array obj{conversation_id, node_id, npc_id, text}
				if(filterErrors(event, "npcs.getConversations"))
				{
					for each(var obj:Object in event.result.data)
					{
						(currentGameObject as Character).addChoice(new Choice(getGameObjectReference(obj.node_id, GameObjectReference.PAGE),
																			  obj.text,
																			  obj.conversation_id)
																   );
					}
					currentGameObject.takeSnapshot();
				}
			}
			
			private function on_npcs_getNpcResult(event:ResultEvent):void
			{ //takes gameID, npcID, returns obj{description, media, name, npc_id, require_event_id, text}
				if(filterErrors(event, "npcs.getNpc"))
				{
					var requirements:Array = new Array();
					var choices:Array = new Array();
					currentGameObject = new Character(getGameObjectReference(event.result.data.npc_id, GameObjectReference.CHARACTER),
												 event.result.data.description, event.result.data.media, requirements, choices,
												 event.result.data.text);
					npcs.getConversations.send(currentGameID, int(event.result.data.npc_id));
					assignInstances();
					currentGameObject.takeSnapshot();
					if(creatingNewObject)
					{ //don't create an event for npcs - they can't have one in the database right now
						creatingNewObject = false;
					}
					updateView();				 
				}								
			}
			
			private function on_npcs_getNpcsResult(event:ResultEvent):void
			{
				if(filterErrors(event, "npcs.getNpcs"))
				{
					var newChildren:Array = new Array();
					for each(var obj:Object in event.result.data)
					{
						newChildren.push(new GameObjectReference(obj.npc_id, GameObjectReference.CHARACTER, obj.name));
					}
					characterFolder.children = newChildren;
					gameObjectsArrayCollection.itemUpdated(characterFolder);
					updateView();
				}				
			}
			
			private function on_npcs_updateConversationResult(event:ResultEvent):void
			{ //takes gameID, conversationID, newNpcID, newNodeID, newText, returns true on success
				filterErrors(event, "npcs.updateConversation");
			}
			
			private function on_npcs_updateNpcResult(event:ResultEvent):void
			{ //takes gameID, npcID, name, descr, greeting, media, returns true on success
				filterErrors(event, "npcs.updateNpc");
			}
			
			private function on_playerStateChanges_createPlayerStateChangeResult(event:ResultEvent):void
			{ //takes gameID, objType, objID, actionType, actionID, returns playerStateChangeID
				filterErrors(event, "playerStateChanges.createPlayerStateChange");
			}
			
			private function on_playerStateChanges_deletePlayerStateChangeResult(event:ResultEvent):void
			{ //takes gameID, playerStateChangeID, returns ???
				filterErrors(event, "playerStateChanges.deletePlayerStateChange");
			}
			
			private function on_playerStateChanges_getPlayerStateChangesForObjectResult(event:ResultEvent):void
			{//takes gameID, objType, objID, returns obj{action, action_detail, content_id, content_type, id}
				if(filterErrors(event, "playerStateChanges.getPlayerStateChangesForObject"))
				{
					for each(var obj:Object in event.result.data)
					{
						if(obj.action != PlayerModification.GIVE_EVENT)
						{ // The only events we use are the automatically generated ones, which we don't display to the user,
						  // and we don't need to keep track of them here
							var mod:PlayerModification;
							mod = new PlayerModification(getGameObjectReference(obj.action_detail, GameObjectReference.ITEM), obj.action, obj.id);
							if(currentGameObject is Item)
							{
								(currentGameObject as Item).addPlayerModification(mod);
							}
							else if(currentGameObject is Page)
							{
								(currentGameObject as Page).addPlayerModification(mod);
							}						
						}
					}
				}
				currentGameObject.takeSnapshot();
			}
			
			private function on_playerStateChanges_updatePlayerStateChangeResult(event:ResultEvent):void
			{
				filterErrors(event, "playerStateChanges.updatePlayerStateChange");
			}
			
			private function on_qrcodes_createQRCodeResult(event:ResultEvent):void
			{//takes gameID, qrcode, objType, objID, xpos, ypos, returns id
				filterErrors(event, "qrcodes.createQRCode");
			}
			
			private function on_qrcodes_deleteQRCodeResult(event:ResultEvent):void
			{// takes gameID, qrcode, returns true if successful
				filterErrors(event, "qrcodes.deleteQRCode");
			}
			
			private function on_qrcodes_getQRCodesResult(event:ResultEvent):void
			{//takes gameID, returns {qrcode_id, type, type_id, x_position, y_position}
				if(filterErrors(event, "qrcodes.getQRCodes"))
				{
					this.qrCodeInstanceList = new Array();
					var codes:Array = event.result.data.source as Array;
					for each(var obj:Object in codes)
					{
						var instance:QRCodeInstance = new QRCodeInstance(getGameObjectReference(obj.type_id, obj.type),
																		 obj.qrcode_id,
																		 obj.x_position,
																		 obj.y_position
																		 );
						instance.makeMarker();
						this.qrCodeInstanceList.push(instance);
					}
					updateView();
				}
			}
			
			private function on_qrcodes_updateQRCodeResult(event:ResultEvent):void
			{//takes gameID, qrcode, objTYpe, objID, xpos, ypos, returns true if successful
				filterErrors(event, "qrcodes.updateQRCode");
			}
			
			private function on_quests_createQuestResult(event:ResultEvent):void
			{ //takes gameID, name, incompletedescription, completedescription, media, returns questID
				if(filterErrors(event, "quests.createQuest"))
				{
					setCurrentGameObject(new GameObjectReference(int(event.result.data), GameObjectReference.QUEST, "My New Quest"));
				}				
			}
			
			private function on_quests_deleteQuestResult(event:ResultEvent):void
			{ //takes gameID, questID, returns true if successful
				if(filterErrors(event, "quests.deleteQuest"))
				{
					currentGameObject = null;
				}
				getCurrentGameData();				
			}
			
			private function on_quests_getQuestResult(event:ResultEvent):void
			{ //takes gameID, questID, returns obj{description, media, name, quest_id, text_when_complete}
				if(filterErrors(event, "quests.getQuest"))
				{
					var requirements:Array = new Array();
					var objectives:Array = new Array();
					currentGameObject = new Quest(getGameObjectReference(event.result.data.quest_id, GameObjectReference.QUEST),
												  event.result.data.description, event.result.data.media, requirements, objectives,
												  event.result.data.text_when_complete);
					currentGameObject.takeSnapshot();
					if(creatingNewObject)
					{//don't create an event for quests - they can't have one in the database right now
						creatingNewObject = false;
					}
					updateView();				 
				}								
			}
			
			private function on_quests_getQuestsResult(event:ResultEvent):void
			{
				if(filterErrors(event, "quest.getQuests"))
				{
					var newChildren:Array = new Array();
					for each(var obj:Object in event.result.data)
					{
						newChildren.push(new GameObjectReference(obj.quest_id, GameObjectReference.QUEST, obj.name));
					}
					questFolder.children = newChildren;
					gameObjectsArrayCollection.itemUpdated(questFolder);
					updateView();
				}				
			}
			
			private function on_quests_updateQuestResult(event:ResultEvent):void
			{ //takes gameID, questID, name, incompleteDescr, completeDescr, media, returns true if successful
				filterErrors(event, "quests.updateQuest");
			}
			
			private function on_requirements_createRequirementResult(event:ResultEvent):void
			{ //takes gameID, strObjType, objID, reqTYpe, reqTypeID, returns new reqID
				filterErrors(event, "requirements.createRequirement");
			}
			
			private function on_requirements_deleteRequirementResult(event:ResultEvent):void
			{
				filterErrors(event, "requirements.deleteRequirement");
			}
			
			private function on_requirements_getRequirementsForObjectResult(event:ResultEvent):void
			{
				if(filterErrors(event, "requirements.getRequirementsForObjectResult"))
				{
					for each(var obj:Object in event.result.data)
					{
						var ref:GameObjectReference;
						var reqCode:int;
						var eventID:int;
						if(obj.requirement == Requirement.HAS_ITEM || obj.requirement == Requirement.DOES_NOT_HAVE_ITEM)
						{
							eventID = getEventIDFromEventCode(GameObjectReference.ITEM + obj.requirement_detail.toString());
							ref = getGameObjectReference(obj.requirement_detail, GameObjectReference.ITEM);
							if(obj.requirement == Requirement.HAS_ITEM)
							{
								reqCode = 0;
							}
							else
							{
								reqCode = 1;
							}
						}
						else if(obj.requirement == Requirement.HAS_EVENT || obj.requirement == Requirement.DOES_NOT_HAVE_EVENT)
						{
							eventID = obj.requirement_detail;
							var evtCode:String = getEventCodeFromEvent(eventID);
							ref = getGameObjectReferenceFromEventCode(evtCode);
							if(evtCode.indexOf(GameObjectReference.ITEM) == 0)
							{
								reqCode = 2;
							}
							else
							{
								reqCode = 0;
							}
							if(obj.requirement == Requirement.DOES_NOT_HAVE_EVENT)
							{
								reqCode++;
							}
						}
						if(obj.content_type == Requirement.QUEST_COMPLETE)
						{
							(currentGameObject as Quest).addObjective(new Requirement(ref, reqCode, obj.requirement_id, eventID));
						}
						else
						{
							currentGameObject.addRequirement(new Requirement(ref, reqCode, obj.requirement_id, eventID));					
						}
					}
				}
				currentGameObject.takeSnapshot();
			}
			
			private function on_requirements_updateRequirementResult(event:ResultEvent):void
			{
				filterErrors(event, "requirements.updateRequirement");
			}
			
			private function updateCurrentGame():void
			{
				if(currentGameObject != null)
				{					
					var differences:Array = currentGameObject.getDifferences();
					for each(var diff:String in differences)
					{
						if(diff == GameObject.MODIFY)
						{
							if(currentGameObject is Character)
							{
								npcs.updateNpc.send(currentGameID,
													currentGameObject.getID(),
													currentGameObject.getName(),
													currentGameObject.getDescription(),
													(currentGameObject as Character).getGreeting(),
													currentGameObject.getMediaFileName()
													);
							}
							else if(currentGameObject is Item)
							{
								var destroyable:int = 0;
								var droppable:int = 0;
								if((currentGameObject as Item).isDestroyable())
								{
									destroyable = 1;
								}
								if((currentGameObject as Item).isDroppable())
								{
									droppable = 1;
								}
								items.updateItem.send(currentGameID,
													  currentGameObject.getID(),
													  currentGameObject.getName(),
													  currentGameObject.getDescription(),
													  currentGameObject.getMediaFileName(),
													  droppable, destroyable
													  );
							}
							else if(currentGameObject is Page)
							{//takes gameID, nodeID, title, text, media, opt1text, opt1nodeID, opt2text, opt2nodeid, opt3text, opt3nodeid, QAcorrectanswer, QAincorrectnodeid, QAcorrectnodeid, returns true if successful
								var choices:Array = (currentGameObject as Page).getChoices();
								while(choices.length < Page.MAX_NUM_CHOICES)
								{// fill in empty choices with blank data
									choices.push(new Choice(new GameObjectReference(0, GameObjectReference.PAGE, ""), "", 0));
								} 
								nodes.updateNode.send(currentGameID,
													  currentGameObject.getID(),
													  currentGameObject.getName(),
													  currentGameObject.getDescription(),
													  currentGameObject.getMediaFileName(),
													  (choices[0] as Choice).choiceText,
													  (choices[0] as Choice).getPageID(),
													  (choices[1] as Choice).choiceText,
													  (choices[1] as Choice).getPageID(),
													  (choices[2] as Choice).choiceText,
													  (choices[2] as Choice).getPageID(),
													  "", 0, 0
													  );								  
							}
							else if(currentGameObject is Quest)
							{
								quests.updateQuest.send(currentGameID,
														currentGameObject.getID(),
														currentGameObject.getName(),
														currentGameObject.getDescription(),
														(currentGameObject as Quest).getCompletedDescription(),
														currentGameObject.getMediaFileName()
														);
							}
						}
						else if(diff.indexOf(PlayerModification.ADD) == 0)
						{
							var modToAdd:PlayerModification = getModification(int(diff.substr(PlayerModification.MODIFY.length)));
							playerStateChanges.createPlayerStateChange.send(currentGameID,
																		   currentGameObject.getType(),
																		   currentGameObject.getID(),
																		   modToAdd.getDBCode(),
																		   modToAdd.getItemID()
																		   );
						}
						else if(diff.indexOf(PlayerModification.DELETE) == 0)
						{
							playerStateChanges.deletePlayerStateChange.send(currentGameID,
																			int(diff.substr(PlayerModification.DELETE.length))
																			);
						}
						else if(diff.indexOf(PlayerModification.MODIFY) == 0)
						{
							var id:int = int(diff.substr(PlayerModification.MODIFY.length));
							var modToUpdate:PlayerModification = getModification(id);
							playerStateChanges.updatePlayerStateChange.send(currentGameID,
																			id,
																			currentGameObject.getType(),
																			currentGameObject.getID(),
																			modToUpdate.getDBCode(),
																			modToUpdate.getItemID()
																			);
						}
						else if(diff.indexOf(Requirement.ADD) == 0)
						{
							var reqToAdd:Requirement = currentGameObject.getRequirement(int(diff.substr(Requirement.ADD.length)));
							var objTypeToAdd:String = currentGameObject.getType();
							if(objTypeToAdd == GameObjectReference.QUEST)
							{
								if(reqToAdd == null)
								{
									reqToAdd = (currentGameObject as Quest).getObjective(int(diff.substr(Requirement.ADD.length)));
									objTypeToAdd = Requirement.QUEST_COMPLETE;
								}
								else
								{
									objTypeToAdd = Requirement.QUEST_DISPLAY;
								}
							}
							requirements.createRequirement.send(currentGameID,
																objTypeToAdd,
																currentGameObject.getID(),
																reqToAdd.getDBCode(),
																reqToAdd.getObjectID()
																);
						}
						else if(diff.indexOf(Requirement.DELETE) == 0)
						{
							requirements.deleteRequirement.send(currentGameID,
																int(diff.substr(Requirement.DELETE.length))
																);
						}
						else if(diff.indexOf(Requirement.MODIFY) == 0)
						{
							var reqID:int = int(diff.substr(Requirement.MODIFY.length));
							var reqToUpdate:Requirement = currentGameObject.getRequirement(reqID);
							var objTypeToUpdate:String = currentGameObject.getType();
							if(objTypeToUpdate == GameObjectReference.QUEST)
							{
								if(reqToUpdate == null)
								{
									reqToUpdate = (currentGameObject as Quest).getObjective(reqID);
									objTypeToUpdate = Requirement.QUEST_COMPLETE;
								}
								else
								{
									objTypeToUpdate = Requirement.QUEST_DISPLAY;
								}
							}
							requirements.updateRequirement.send(currentGameID,
																reqID,
																objTypeToUpdate,
																currentGameObject.getID(),
																reqToUpdate.getDBCode(),
																reqToUpdate.getObjectID()
																);		
						}
						else if(diff.indexOf(Choice.ADD) == 0)
						{
							var choiceToAdd:Choice = (currentGameObject as Character).getChoice(int(diff.substr(Choice.ADD.length)));
							npcs.createConversation.send(currentGameID,
														 currentGameObject.getID(),
														 choiceToAdd.getPageID(),
														 choiceToAdd.choiceText
														 );
														 
						}
						else if(diff.indexOf(Choice.DELETE) == 0)
						{
							npcs.deleteConversation.send(currentGameID,
														 int(diff.substr(Choice.DELETE.length))
														 );
						}
						else if(diff.indexOf(Choice.MODIFY) == 0)
						{
							var choiceID:int = int(diff.substr(Choice.MODIFY.length));
							var choiceToUpdate:Choice = (currentGameObject as Character).getChoice(choiceID);
							npcs.updateConversation.send(currentGameID,
														 choiceID,
														 currentGameObject.getID(),
														 choiceToUpdate.getPageID(),
														 choiceToUpdate.choiceText
														 );														 
						}
						else if(diff.indexOf(QRCodeInstance.ADD) == 0)
						{
							var qrToAddID:int = int(diff.substr(QRCodeInstance.ADD.length));
							var qrToAdd:QRCodeInstance = (currentGameObject as InstantiatedGameObject).getQRCodeInstance(qrToAddID);
							qrcodes.createQRCode.send(currentGameID,
													  qrToAddID,
													  qrToAdd.getObjectType(),
													  qrToAdd.getObjectID(),
													  qrToAdd.getXPos(),
													  qrToAdd.getYPos()
													  );
						}
						else if(diff.indexOf(QRCodeInstance.DELETE) == 0)
						{
							qrcodes.deleteQRCode.send(currentGameID,
													  int(diff.substr(QRCodeInstance.DELETE.length))
													  );
						}
						else if(diff.indexOf(QRCodeInstance.MODIFY) == 0)
						{
							var qrToUpdateID:int = int(diff.substr(QRCodeInstance.MODIFY.length));
							var qrToUpdate:QRCodeInstance = (currentGameObject as InstantiatedGameObject).getQRCodeInstance(qrToUpdateID);
							qrcodes.updateQRCode.send(currentGameID,
													  qrToUpdateID,
													  qrToUpdate.getObjectType(),
													  qrToUpdate.getObjectID(),
													  qrToUpdate.getXPos(),
													  qrToUpdate.getYPos()
													  );							
						}
					}
				}
			}
			
			private function updateGameList():void
			{
				games.getGamesForEditor.send(currentEditorID);
			}
			
			private function updateView():void
			{
				this.currentView.update();
			}
			


			/////////////////////////////////////////////
			// Under Construction (Move when finished) //
			/////////////////////////////////////////////			
			
			private function on_items_getReferrersResult(event:ResultEvent):void
			{ //takes gameID, itemID, returns array obj{type, id} *** check!! ***
				
			}
			
			private function on_locations_createLocationForItemResult(event:ResultEvent):void
			{ //takes gameID, strIcon, lat, lng, error, itemID, quantity, hidden, forceview, returns locID
				
			}
			
			private function on_locations_createLocationForNodeResult(event:ResultEvent):void
			{ //takes gameID, strIcon, lat, lng, error, nodeID, hidden, forceview, returns locID
				
			}
			
			private function on_locations_createLocationForNpcResult(event:ResultEvent):void
			{ //takes gameID, strIcon, lat, lng, error, npcID, hidden, forceview, returns locID
				
			}
			
			private function on_locations_deleteLocationResult(event:ResultEvent):void
			{ //takes gameID, locID, returns true if successful
				
			}
			
			private function on_locations_getLocationResult(event:ResultEvent):void
			{ //takes gameID, locID, returns obj{add_event_id, description, error, force_view, hidden, icon, item_qty, latitude, location_id, longitude, name, remove_if_event_id, require_event_id, type, type_id
				
			}
			
			private function on_locations_getLocationsResult(event:ResultEvent):void
			{
				
			}
			
			private function on_locations_objectTypeOptionsResult(event:ResultEvent):void
			{ //takes gameID, returns array of strings
				
			}
			
			private function on_locations_updateAttributesResult(event:ResultEvent):void
			{ //takes gameID, locID, quantity, hidden, forceView, returns true if successful
				
			}
			
			private function on_media_createMediaResult(event:ResultEvent):void
			{ //takes gameID, fileName, returns mediaID
				
			}
			
			private function on_media_deleteMediaResult(event:ResultEvent):void
			{ //takes gameID, mediaID, returns true if successful
				
			}
			
			private function on_media_updateMediaResult(event:ResultEvent):void
			{ //takes gameID, filename, returns true if successful
				
			}
			
			private function on_nodes_getReferrersResult(event:ResultEvent):void
			{ //takes gameID, nodeID, returns ???
				
			}
			
			private function on_npcs_getReferrersResult(event:ResultEvent):void
			{ //takes gameID, npcID, returns ???
				
			}
			
			private function on_playerStateChanges_getReferrersResult(event:ResultEvent):void
			{
				
			}
			
			private function on_qrcodes_getQRCodeResult(event:ResultEvent):void
			{//takes gameID, qrcode, returns array of{qrcode_id, type, type_id, x_position, y_position}
				
			}
			
			private function on_requirements_getReferrersResult(event:ResultEvent):void
			{
				
			}
			
		]]>
	</mx:Script>
	
</mx:UIComponent>
